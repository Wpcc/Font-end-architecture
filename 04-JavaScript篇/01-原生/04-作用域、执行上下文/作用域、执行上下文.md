# 作用域、执行上下文

### 作用域

**作用域：变量作用的区域，主要用来寻找变量。**以函数为例，由于JavaScript是静态作用域（词法作用域），也就是说函数的作用域，在函数声明的时候就已经决定了。

下面的例子很好的说明了这个问题：

```javascript
let value = 'global'
function foo(){
    console.log(value)
}
function bar(){
    let value = 'bar'
    foo()
}
bar() //
```



### 执行上下文

JavaScript 引擎并不是一行一行的分析执行代码，而是一段一段的分析执行代码，**我们把段的划分称呼为执行上下文栈，把执行代码之前的分析工作称呼为执行上下文。**

#### 执行上下文栈

**执行上下文栈**（Execution context stack，ECS），下文简称为执行栈，通常来讲JavaScript存在着三种执行栈，即全局执行栈，函数执行栈和eval执行栈。

下面来看一个关于执行栈的模拟，假设我们将执行栈定义为一个数组：

```javascript
ECStack = []
```

现在JavaScript遇到下面这段代码：

```javascript
function foo3(){
    console.log('foo3')
}
function foo2(){
    foo3()
}
function foo1(){
    foo2()
}
foo1()
```

那么这段代码的执行栈则如下：

```javascript
// 伪代码
ECStack = []
ECStack.push(globalContext) // 全局栈
// foo1
ECStack.push(<foo1> functionContext)
// foo2
ECStack.push(<foo2> functionContext)
// foo3
ECStack.push(<foo3> functionContext)

// foo3执行完毕
ECStack.pop()
// foo2执行完毕
ECStack.pop()
// foo1执行完毕
ECStack.pop()

// 全局执行栈会等到程序结束之前才会被弹出
```

关于执行上下文栈，如果你真的弄清楚了，请尝试着分析下面两串代码：

```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```

```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```



#### 执行上下文

关于执行上下文栈的解释到这里就结束了，在每个执行上下文栈中，也就是代码执行之前都会**创建对应的执行上下文（execution context）**。

对每个执行上下文，都有三个重要的属性：

- 变量对象（variable object，VO）
- 作用域链（Scope chain）
- this

下面我们先看两个例子，尽管这会让我们感到疑惑，但对于**执行上下文**我们会有更加直观的感受。

```javascript
// 变量
var foo = function(){
    console.log('foo1')
}
foo() // foo1
var foo = function(){
    console.log('foo2')
}
foo() // foo2
```

```javascript
// 函数
function foo(){
    console.log('foo1')
}
foo() // foo2
function foo(){
    console.log('foo2')
}
foo() // foo2
```

我们知道不管是变量还是函数，在整个执行过程中确切的可以分为两步：

- 声明

- 调用

对于变量而言，执行上下文的处理是`var foo = undefined`，而对于函数的处理则是`function foo(){}`。

换言之：

- **变量：声明——赋值——调用**
- **函数：声明——调用**

#### 变量对象

**执行上下文中，用来存储变量和函数声明。**全局上下文的变量对象为**window**，函数上下文中的变量对象则为活动对象（activation object，AO），活动对象并没有明确的API可以访问。

现在我们知道代码执行分为两步：

1、进入执行上下文

2、代码执行

当代码在执行上下文阶段，变量对象会包含以下三个内容：

1. 函数的所有形参 (如果是函数上下文)
   - 由名称和对应值组成的一个变量对象的属性被创建
   - 没有实参，属性值设为 undefined
2. 函数声明
   - 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
   - 如果变量对象已经存在相同名称的属性，则完全替换这个属性
3. 变量声明
   - 由名称和对应值（undefined）组成一个变量对象的属性被创建；
   - 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性

以下面代码为例：

```javascript
function foo(a){
    var b = 2
    funciton c(){}
    var d = function(){}
    b = 3
}
foo(1)
```

AO如下：

```javascript
AO = {
    arguments:{
        0:1,
        length:1
    },
    a:1,
    b:undefined,
    c:reference to function c(){},
    d:undefined
}
```

代码会顺序执行，执行完毕后的AO如下：

```javascript
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}
```



