### 节流和防抖

在前端开发中，我们通常会遇到一些频繁的事件触发，如：

- window 的 resize、scroll
- mousedown、mounsemove
- keyup、keydown

下面用一个小案列来演示一下如何频繁的触发事件：

```html
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="IE=edge, chrome=1">
    <title>节流和防抖</title>
    <style>
        #container{
			width: 100%;
			height: 200px;
			line-height: 200px;
			background-color: #555;
			color: #fff;
			text-align: center;
		}
    </style>
</head>

<body>
    <div id="container"></div>
</body>
<script>
	var count = 1
	var container = document.querySelector('#container')
	function add(){
		contaienr.innerHTML = count++
	}
	container.onmousemove = add
</script>
</html>
```

可以看见，当在 container 元素中移动鼠标，会频繁触发add函数。那怎么才能降低这种频繁触发函数的行为呢，这就要提到两种方案，**节流和防抖**。

节流（throttle），在规定的时间里，用户只能触发一次事件函数。

防抖（debounce），用户行为结束后，在规定的时间才开始触发一次事件函数。

图解说明：



### 节流

节流（throttle），在规定的时间里，用户只能触发一次事件。节流有两种实现：

- 时间戳，在规定时间的起始位置触发事件
- 定时器，在规定事件的结束位置触发事件

时间戳实现原理：

- 定义初始时间变量为0
- 获取用户触发事件时的时间戳
- 将该时间戳减去初始时间
  - 如果大于规定的时间，则执行事件函数，并将初始时间设置为当前时间戳

```javascript
function throttle(fn,interval){
    var last = 0
    return function(){
        var context = this
        var args = arguments
        
        var now = +new Date()
        if(now - last > interval){
            fn.apply(context,args)
        }
    }
}
```

那么至此最开始频繁触发事件的代码就可以改写成下面代码：

```javascript
container.onmounsemove = throttle(add,1000) // 每隔1秒钟触发一次add函数
```

针对节流代码的说明：

`+new Date()`：获取时间戳（这里有个隐形转换），也可以通过`Date.now()`获取

`var context = this`：将事件函数的this绑定到DOM元素上

`var args = arguments`：将传递给函数的事件对象传递给处理函数

如果对于以上的解释，你还不是足够的清楚，

