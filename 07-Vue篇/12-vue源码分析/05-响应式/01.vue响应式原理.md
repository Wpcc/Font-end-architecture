# vue响应式原理

为了弄清这个概念，我们先看以下代码：

```vue
<template>
	<div id="app">
        {{a.b}}
    </div>
</template>
<script>
var vm = new Vue({
    data:{
        a:{
            b:'i am b'
        },
        c:'i am c'
    },
    watch:{
        c(newVal,oldVal){
            console.log('当c改变了触发了监听')
        }
    },
    created(){
        this.a.b = 'changed b'
        this.c = 'changed c'
    }
}).$mount('#app')
</script>
```

通过观察代码，我们知道，以上代码中：

- 模板字符串使用了  `a.b`
- 监听器使用了`c`

当我们在生命周期`created`中修改`a.b`的值以及`c`的值，我们发现模板字符串中`a.b`的值和`watch`中`c`的值也发生了改变。

那么对于这种情况，我们就称为响应式。

即你使用了我，当我发生改变，我会通知你进行对应的改变。

### 响应式实现

具体代码可以查看`demo`中响应式的基本实现。



### vue的响应式

还是以第一个示例为说明，不管是字符串模板还是`watch`，我们可以把这种需要用到数据的类型抽象一下，抽象为统一的**依赖**。

那么对于对象，我们知道有`defineProperty`可以定义`getter`和`setter`，

- 在`getter`中，我们可以把访问该属性的**依赖**收集起来
- 在`setter`中，我们就把收集起来的**依赖**重新执行一遍（如果是模板让它重新渲染，如果是计算器或监听器则执行该函数），这个时候他们就会去拿到新的值。

假设有以下数据：

```javascript
var data = {
    a:'a',
    obj:{
        b:'b'
    },
    arr:['c']
}
```

当我们使用vue对该数据进行初始化：

- `initData`会调用`observe（data,true）`函数并将data数据进行传参
- `observe`会调用`ob = new Observer(value)`构造函数，**构造ob观察者，并将结果返回**。
  - 之所有返回结构，主要是为了后续`let childOb = !shallow && observe(val)`做判断
- `Observer`构造函数，给ob对象添加属性，给value添加`__ob__`属性指向ob观察者，对数组和对象使用不同的处理方式
  - 对象
    - 调用`walk`函数循环对象中的每一项，并用`defineReactive(obj, keys[i])`进行处理
    - `defineReactive`

```javascript
function initData(vm){
    
}
```



除了基础对象上的属性都**添加了自己的依赖收集器`new Dep()`,**记住是每个属性，包括基础属性和对象属性（对象或数组）。不同的是对象属性有自己额外的`__ob__`属性。

```javascript
var data = {
    a:'a',
    obj:{
        b:'b',
        __ob__:{
            value:obj,
            dep:new Dep(),
            vmCount:0
        }
    },
    // 数据也添加了__ob__属性
    arr:['c'], // arr.__ob__:{value:arr,dep:new Dep(),vmConut:0}
    __ob__:{
        value:data,
        dep:new Dep(),
        vmCount:1
    }
}
```

### `__ob__`

对于对象属性来说，`__ob__`主要是用来实现`$set`和`$delete`。

```javascript
export function set (target: Array<any> | Object, key: any, val: any): any {
  if (process.env.NODE_ENV !== 'production' &&
    (isUndef(target) || isPrimitive(target)) // 是否是undefine null 或原始数据类型
  ) {
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) { // 是否是有效的key
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val) // 使用splice
    return val
  }
  if (key in target && !(key in Object.prototype)) { // 如果设置的是对象上有的属性
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__
  if (target._isVue || (ob && ob.vmCount)) { // 根数据对象不是响应式
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
    return val
  }
  if (!ob) { // 如果该对象不是响应式
    target[key] = val
    return val
  }
  defineReactive(ob.value, key, val) // 定义该属性响应式
  ob.dep.notify() // 通知对象所有依赖
  return val
}
```

### 数组的实现

首先是收集依赖：

	- 数组本身也是对象上的属性，所以当访问数组时收集依赖的行为，通过源码可以看到：

```javascript
get: function reactiveGetter () {
    const value = getter ? getter.call(obj) : val
    if (Dep.target) {
        dep.depend() // 本身内部定义的收集器：收集依赖
        if (childOb) { // __ob__：收集和内部收集器一样的依赖
            childOb.dep.depend()
            if (Array.isArray(value)) { // 如果数组中有对象或数组，通知他们__ob__收集依赖
                dependArray(value)
            }
        }
    }
    return value
}
```

