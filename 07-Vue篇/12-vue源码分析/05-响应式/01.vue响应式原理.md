# vue响应式原理

为了弄清这个概念，我们先来看一下vue里面有哪些响应式：

```vue
<template>
	<div id="app">
        {{a.b}}
    </div>
</template>
<script>
var vm = new Vue({
    data:{
        a:{
            b:'i am b'
        },
        c:'i am c'
    },
    watch:{
        c(newVal,oldVal){
            console.log('当c改变了触发了监听')
        }
    }
}).$mount('#app')
</script>
```

通过以上代码，我们知道：

- 当使用watch监听数据时，数据发生变化时，也就触发了依赖（观察者）。

- 同样当数据发生变化时，也触发了相应的template模板依赖

  

### 数据依赖

我们先来解决数据依赖问题。

- 定义一个数据，用来收集依赖
- 假设fn为相应的依赖

```javascript
// dep 数组就是我们所谓的“筐”
const dep = []
Object.defineProperty(data, 'a', {
  set () {
    // 当属性被设置的时候，将“筐”里的依赖都执行一次
    dep.forEach(fn => fn())
  },
  get () {
    // 当属性被获取的时候，把依赖放到“筐”里
    dep.push(fn)
  }
})
```

同时我们用$watch去模范一下vue中的监听：

- 第一个参数为监听的对象，第二个参数为触发的依赖

```javascript
$watch('a', () => {
  console.log('设置了 a')
})
```

那么此刻我们需要思考一下，$watch这个函数本质上是做什么的？

- 触发get函数，收集依赖
- 将观察者（依赖）进行一定的传递，方便收集

```javascript
// 那么整个依赖收集系统如下
const data = {
  a: 1
}

const dep = []
Object.defineProperty(data, 'a', {
  set () {
    dep.forEach(fn => fn())
  },
  get () {
    // 此时 Target 变量中保存的就是依赖函数
    dep.push(Target)
  }
})

// Target 是全局变量
let Target = null
function $watch (exp, fn) {
  // 将 Target 的值设置为 fn
  Target = fn
  // 读取字段值，触发 get 函数
  data[exp]
}
```

假设我们在a上定义了两个依赖：

```javascript
$watch('a', () => {
  console.log('第一个依赖')
})
$watch('a', () => {
  console.log('第二个依赖')
})
```

这个时候，当我们修改a的值，会发现控制台分别 打印出`第一个依赖`和`第二个依赖`。

故，到此刻我们一个基本的响应式系统就完成了。

以下会继续深入做一下扩展性的补充。

- 添加递归和循环对data每个数据或嵌套对象做响应式
- 修改$watch，让$watch能够观察到嵌套字段
- 修改$watch，让$watch 能够观察到函数（template模板本质是渲染函数）



### 渲染函数依赖

